#ifndef	_FTPSERVER_H_#define	_FTPSERVER_H_#define MAXUSERS (256)#define MAXACCOUNTS (8)class CFTPUser;class CFTPServer;class CFTPUserList;class CFTPUserManager;typedef HRESULT (*CallbackExec) (PVOID pThis, LPCTSTR szPath, LPCTSTR szCmdLine);typedef void (*CallbackLogon) (PVOID pThis);typedef void (*CallbackLogoff) (PVOID pThis);class CFTPUserFile{public:    char m_name[32];    char m_password[32];    char m_root[256];
    CFTPUserFile (char *name=NULL, char *pw=NULL, char *root=NULL)    {        if (name == NULL) return;        strcpy (m_name, name);        strcpy (m_password, pw);        if (root != NULL)            strcpy (m_root, root);        else            strcpy (m_root, "");    }};

class CFTPUserList{public:    CFTPUser *pUser;    HANDLE hUserThread;    CFTPUserList *pNext;    CFTPUserList (CFTPUser *user = NULL, HANDLE h = NULL, CFTPUserList *list = NULL) : pUser (user), pNext (list), hUserThread (h) {}    ~CFTPUserList ()    {
    }    void RemoveNext ()    {        CFTPUserList *p = pNext;        pNext = pNext->pNext;        delete p;    }};

class CFTPUserManager{public:    CFTPUserManager () : m_pList (NULL) {}    ~CFTPUserManager () {}    void Add (CFTPUser *pUser, HANDLE handle)    {        CFTPUserList *p = new CFTPUserList (pUser, handle, m_pList);        m_pList = p;    }    void DeleteByHandle (HANDLE h)    {        // Special case #1...  It's the first item.        if (m_pList->hUserThread == h)        {            CFTPUserList *p = m_pList;            m_pList = m_pList->pNext;            delete p;            return;        }        CFTPUserList *p = m_pList;        while ((p->pNext != NULL)  && (p->pNext->hUserThread != h))        {            p = p->pNext;        }        if (p->pNext != NULL)            p->RemoveNext ();    }    int GetCount ()    {        CFTPUserList *p = m_pList;        int n = 0;        while (p != NULL)        {            n++;            p = p->pNext;        }        return n;    }    CFTPUser *GetUser (int idx)    {        CFTPUserList *p = m_pList;        int n = 0;        while ((p != NULL) && (n != idx))        {            p = p->pNext;            n++;        }        if (p == NULL)            return NULL;        return p->pUser;    }
private:    CFTPUserList *m_pList;};


class CFTPServer{public:    CFTPServer (char *userfile = NULL, unsigned short port = 21) : m_bRunning (false), m_bShutdown (false), m_port (port), m_logon (NULL), m_logoff (NULL)    {        // Let's make sure that WSA is started...  No harm in calling it more than once.        WSADATA WSAData;        ::WSAStartup (MAKEWORD (2, 2), &WSAData);
        // here's where we load the userfile...        if (userfile != NULL)        {            int u = 0;            // Actually load the user file            HANDLE hFile = ::CreateFile (userfile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);            if (hFile != INVALID_HANDLE_VALUE)            {                char buf[255];                bool bEndOfFile = false;                while (!bEndOfFile)                {                    char c = 0;                    int n=0;                    unsigned long el;                    while ((c != '\n') && (!bEndOfFile))                    {						if (ReadFile (hFile, &c, 1, &el, NULL) == 0)                            bEndOfFile = true;                        else                           buf[n++] = c;                     }                    buf[n] = 0;                    if (buf[0] == '#')                    {                        char *sz;                        char del[] = " ,\n\r\t";                        sz = strtok (buf, del);                        if (strcmp (sz, "#USER") == 0)                        {                            char *name, *pw, *root;                            name = strtok (NULL, del);                            pw = strtok (NULL, del);                            root = strtok (NULL, del);                            m_FileUsers[u++] = CFTPUserFile (name, pw, root);                        }                        else if (strcmp (sz, "#ANON") == 0)                        {                            char *allow, *root;                            allow = strtok (NULL, del);                            root = strtok (NULL, del);                            m_bAllowAnon = (strcmp (allow, "1") == 0);                            strcpy (m_AnonRoot, root);                        }						else if (strcmp (sz, "#IP") == 0)						{							char *h1, *h2, *h3, *h4;							h1 = strtok (NULL, del);							h2 = strtok (NULL, del);							h3 = strtok (NULL, del);							h4 = strtok (NULL, del);							m_h1 = atoi (h1);							m_h2 = atoi (h2);							m_h3 = atoi (h3);							m_h4 = atoi (h4);							m_bCfgIP = true;						}                    }                }            }            CloseHandle (hFile);            m_nFileUsers = u;            return;        }        // default to xbox/xbox.        m_FileUsers[0] = CFTPUserFile("xbox", "xbox", ""); // xbox:xbox has root		m_FileUsers[1] = CFTPUserFile("games", "games", "\\f\\games");        m_nFileUsers = 2;        m_bAllowAnon = true;        strcpy (m_AnonRoot, "c:");    }    ~CFTPServer ()    {        Stop ();        ::WSACleanup ();    }    DWORD Start ();  // starts the server    DWORD Stop ();   // stops the server    DWORD Serve ();  // must be run in it's own thread.  Started by call to .Start ()    DWORD ValidateLogin (char *user, char *pw, char *root);    CFTPUserManager m_Users;    int GetUserCount ();    void GetUserInfo (int idx, char **username, char **pw, char **curdir, char **ip);    void SetEXECCallback (CallbackExec cb, PVOID pv)    {        m_exec = cb;        m_execThis = pv;    }    void SetLogoffCallback (CallbackLogoff cb, PVOID pv)    {        m_logoff = cb;        m_logoffThis = pv;    }    void SetLogonCallback (CallbackLogon cb, PVOID pv)    {        m_logon = cb;        m_logonThis = pv;    }    CallbackExec m_exec;    CallbackLogon m_logon;    CallbackLogoff m_logoff;    void *m_logonThis;    void *m_logoffThis;    void *m_execThis;    bool m_bRunning;  // Is the server running?	bool m_bCfgIP;	unsigned int m_h1, m_h2, m_h3, m_h4;private:    bool m_bShutdown; // are we shutting down?    bool m_bAllowAnon; // allow anon login?    char m_AnonRoot[256];    unsigned short m_port; // The port we're listening on    void *pUsers;    SOCKET m_sockListen;  // The socket we're going to listen to.    HANDLE m_hThreadServer; // The handle to the server's thread.    CFTPUserFile m_FileUsers[MAXACCOUNTS];    int m_nFileUsers;};#endif#ifndef __FTPUSERMANAGER__#include "ftpUser.h"#endif